import csv
import re
from time import sleep
import urllib.request
from keras.callbacks import EarlyStopping, ModelCheckpoint
from keras.engine.saving import load_model
# from matplotlib import pyplot
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
# import matplotlib.pyplot as plt
import os
import zipfile
import keras
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten, Conv1D, MaxPooling1D, AveragePooling1D, \
    GlobalAveragePooling1D, BatchNormalization
from keras.optimizers import SGD
# from skimage.viewer.widgets import history
from sklearn import preprocessing, linear_model, metrics
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.pipeline import Pipeline
from sklearn.metrics import classification_report, confusion_matrix


def read_data(file_path):
    raw = []
    labels = []

    with open(file_path, mode='r') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=',')
        for row in csv_reader:
            labels.append(1 if 'malicious' in row[0] else 0)
            raw.append(row[1:])

    return raw, labels

def evaluate(scores):
    m, s = np.mean(scores), np.std(scores)

    print('Accuracy: {} +/- ({})'.format(m, s))


def main():

    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

    train_smartphones1, train_labels1 = read_data('/home/john/Licenta/100k.csv')
    sleep(10)
    train_smartphones, test_smartphones, train_labels, test_labels = train_test_split(train_smartphones1, train_labels1, test_size=0.3)

    train_smartphones = np.array(train_smartphones, dtype=np.float32)
    test_smartphones = np.array(test_smartphones, dtype=np.float32)
    train_labels = np.array(train_labels, dtype=np.int)
    test_labels = np.array(test_labels, dtype=np.int)

    print('Train smartphones shape {}'.format(train_smartphones.shape))

    alpha = np.random.randint(2, 10, 1)
    num_classes = 20

    encoder = LabelEncoder()
    encoder.fit(train_labels)
    encoded_Y = encoder.transform(train_labels)
    train_labels = keras.utils.to_categorical(encoded_Y)

    encoder = LabelEncoder()
    encoder.fit(test_labels)
    encoded_Y = encoder.transform(test_labels)
    test_labels = keras.utils.to_categorical(encoded_Y)

    hidden_layers = int(train_smartphones.shape[0] / (alpha * (train_smartphones.shape[1] + num_classes)))

    model2 = baseline_model(hidden_layers, num_classes, train_labels, train_smartphones, test_smartphones, test_labels)

    _, score2 = model2.evaluate(train_smartphones, train_labels)
    _, score3 = model2.evaluate(test_smartphones, test_labels)

    score2 = score2 * 100.0
    score3 = score3 * 100.0

    print('Test score ------> {}'.format(score3))
    print('Train score -----> {}'.format(score2))
    print(confusion_matrix(test_labels, model2.predict_classes(test_smartphones)))


def baseline_model(hidden_layers, num_classes, train_labels, train_smartphones, test_X, test_Y):
    model = Sequential()
    model.add(Dense(256, input_shape=(train_smartphones.shape[1], ),activation='relu'))
    model.add(Dropout(0.3))
    model.add(Dense(256, activation='relu'))
    model.add(Dropout(0.3))
    model.add(Dense(2, activation='softmax'))
    sgd = SGD(lr=0.01, decay=1e-6, momentum=0.9, nesterov=True)
    model.compile(loss='categorical_crossentropy', optimizer=sgd, metrics=['accuracy'])

    es = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=100)
    mc = ModelCheckpoint('best_model2.h5', monitor='val_acc', mode='max', save_best_only=True)

    model.fit(train_smartphones, train_labels, epochs=400, verbose=1, validation_split=0.3,
              callbacks=[es, mc])

    saved_model = load_model('best_model2.h5')

    return saved_model

main()