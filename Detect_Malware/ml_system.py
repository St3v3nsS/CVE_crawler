import csv
import re
import os
import zipfile
import keras
import seaborn as sns
import pandas as pd
import sys
from tqdm import tqdm
sys.path.append('/home/john/Project/CVE_crawler/')
from keras.utils import plot_model

# import warnings filter
from warnings import simplefilter
# ignore all future warnings
simplefilter(action='ignore', category=FutureWarning)
from Detect_Malware import download_google_drive as download
from time import sleep
from Loggers import logger
from keras.callbacks import EarlyStopping, ModelCheckpoint, History
from keras.models import load_model
import numpy as np
from matplotlib.ticker import FuncFormatter
import matplotlib.pyplot as plt
from sklearn.utils.multiclass import unique_labels
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten, Conv1D, MaxPooling1D, AveragePooling1D, \
    GlobalAveragePooling1D, BatchNormalization
from sklearn import preprocessing, linear_model, metrics
from sklearn.model_selection import train_test_split, StratifiedKFold
from sklearn.preprocessing import LabelEncoder
from sklearn.pipeline import Pipeline
from sklearn.metrics import classification_report, confusion_matrix
import Detect_Malware.encode_content as encode_content

def read_data(file_path):
    raw = []
    labels = []

    with open(file_path, mode='r') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=',')
        for row in csv_reader:
            labels.append(1 if 'malicious' in row[0] else 0)
            raw.append(row[1:])

    return raw, labels

def read_data1(file_path):
    logger.myLogger("ML model").info("Reading dataset...")
    malwaredf = pd.read_csv(file_path, sep=',', header=None)
    malwaredf = malwaredf.values
    X = malwaredf[:,1:].astype(float)
    Y = malwaredf[:,0]
    logger.myLogger("ML model").info("Done reading...")

    return Y, X 

def plot_confussion(y_true, y_pred, classes, title, cmap=plt.cm.Blues):
    cf_matrix = confusion_matrix(y_true, y_pred)

    group_names = ['True Neg','False Pos','False Neg','True Pos']
    group_counts = ["{0:0.0f}".format(value) for value in cf_matrix.flatten()]
    group_percentages = ["{0:.2%}".format(value) for value in
                     cf_matrix.flatten()/np.sum(cf_matrix)]
    labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names,group_counts,group_percentages)]

    labels = np.asarray(labels).reshape(2,2)
    plt.figure()
    sns.heatmap(cf_matrix,annot=labels, fmt='', cmap='Blues')
    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')

def get_csv(csv_dest):

    destianation = '/home/john/Project/CVE_crawler/Detect_Malware/dataset.zip'
    file_id = '1HIJShr0GvQCUp_0R_kQe_WLG5PippurN'
    
    if not os.path.exists(csv_dest):
        try:
            download.download_file_from_google_drive(file_id, destianation)

            logger.myLogger("ML model").info("Extracting...")
            with zipfile.ZipFile(destianation, 'r') as zip_ref:
                for member in tqdm(zip_ref.infolist(), desc='Extracting '):
                    try:
                        zip_ref.extract(member, csv_dest)
                    except zipfile.error as e:
                        pass

            if os.path.exists(destianation):
                os.remove(destianation)
            logger.myLogger("ML model").info("Done ...")
        except ValueError as e:
                print(e)

def main(name):
    csv_dest = '/home/john/Project/CVE_crawler/Detect_Malware/dataset.csv'
    
    get_csv(csv_dest)
    train_Y, train_X = read_data1(csv_dest+'/dataset.csv')

    encoder = LabelEncoder()
    encoder.fit(train_Y)
    train_Y = encoder.transform(train_Y)

    if name != "debug":
        os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

        train_X, test_X, train_Y, test_Y = train_test_split(train_X, train_Y, test_size=0.3)
        
        model = main_model(train_Y, train_X)
        _, train_score = model.evaluate(train_X, train_Y)
        _, test_score = model.evaluate(test_X, test_Y)

        train_score = train_score * 100.0
        test_score = test_score * 100.0

        logger.myLogger("ML model").info(f'Test score ------> {test_score}')
        logger.myLogger("ML model").info(f'Train score -----> {train_score}')

        y_pred = model.predict_classes(test_X)
        plt.figure()
        plot_confussion(test_Y, y_pred, [0, 1], "Test Confussion matrix")
        plt.savefig('cfmatrix.png', bbox_inches='tight')
        plt.figure()
        y_pred = model.predict_classes(train_X)
        plot_confussion(train_Y, y_pred, [0, 1], "Test Confussion matrix")
        plt.savefig('cfmatrix_train.png', bbox_inches='tight')

        

    else:
        model = load_model('best_model.h5')
        logger.myLogger("ML model").info("Got model")

        np_arr = np.array([encode_content.encode_pe('/home/john/Project/CVE_crawler/Server/Files/malw.exe_'), ])
        prediction = get_prediction_encoder(model, np_arr, encoder)
        logger.myLogger("ML model").info(f"Predicted: {prediction}")

def get_prediction_encoder(model, test_X, encoder):
    predicted_classes =  model.predict_classes(test_X)
    return encoder.inverse_transform(predicted_classes[0])[0]

def get_predictions(model, test_X):
    return 'pe-malicious' if model.predict_classes(test_X)[0] == [1] else 'pe-legit'

def main_model(train_Y, train_X):
    model = Sequential()
    model.add(Dense(256, input_shape=(train_X.shape[1], ),activation='relu'))
    model.add(Dropout(0.5))
    model.add(Dense(128, activation='relu'))
    model.add(Dense(64, activation='relu'))
    model.add(Dropout(0.3))
    model.add(Dense(1, activation='sigmoid'))
    model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

    es = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=100)
    mc = ModelCheckpoint('best_model.h5', monitor='val_acc', mode='max', save_best_only=True)

    model.summary()
    plot_model(model, to_file='model.png')
    history = model.fit(train_X, train_Y, epochs=200, verbose=1, validation_split=0.3,
            callbacks=[es, mc])

    # summarize history for accuracy
    plt.figure()
    plt.plot(history.history['acc'])
    plt.plot(history.history['val_acc'])
    plt.title('model accuracy')
    plt.ylabel('accuracy')
    plt.xlabel('epoch')
    plt.legend(['train', 'test'], loc='upper left')
    plt.savefig('accuracy.png', bbox_inches='tight')
    plt.figure()
    # summarize history for loss
    plt.plot(history.history['loss'])
    plt.plot(history.history['val_loss'])
    plt.title('model loss')
    plt.ylabel('loss')
    plt.xlabel('epoch')
    plt.legend(['train', 'test'], loc='upper left')
    plt.savefig('loss.png', bbox_inches='tight')
    saved_model = load_model('best_model.h5')

    return saved_model

if __name__ == "__main__":
    main("train")
