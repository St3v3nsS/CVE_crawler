import csv
import re
import os
import zipfile
import keras
import seaborn as sns
import pandas as pd
import sys
sys.path.append('/home/john/Project/CVE_crawler/')

# import warnings filter
from warnings import simplefilter
# ignore all future warnings
simplefilter(action='ignore', category=FutureWarning)

from time import sleep
from Loggers import logger
from keras.callbacks import EarlyStopping, ModelCheckpoint
from keras.models import load_model
import numpy as np
from matplotlib.ticker import FuncFormatter
import matplotlib.pyplot as plt
from sklearn.utils.multiclass import unique_labels
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten, Conv1D, MaxPooling1D, AveragePooling1D, \
    GlobalAveragePooling1D, BatchNormalization
from sklearn import preprocessing, linear_model, metrics
from sklearn.model_selection import train_test_split, StratifiedKFold
from sklearn.preprocessing import LabelEncoder
from sklearn.pipeline import Pipeline
from sklearn.metrics import classification_report, confusion_matrix
import Detect_Malware.encode_content as encode_content

def read_data(file_path):
    raw = []
    labels = []

    with open(file_path, mode='r') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=',')
        for row in csv_reader:
            labels.append(1 if 'malicious' in row[0] else 0)
            raw.append(row[1:])

    return raw, labels

def read_data1(file_path):
    logger.myLogger("ML model").info("Reading dataset...")
    malwaredf = pd.read_csv(file_path, sep=',', header=None).values
    X = malwaredf[:,1:].astype(float)
    Y = malwaredf[:,0]
    logger.myLogger("ML model").info("Done reading...")

    return Y, X 

def plot_confussion(y_true, y_pred, classes, title, cmap=plt.cm.Blues):
    cf_matrix = confusion_matrix(y_true, y_pred)

    group_names = ['True Neg','False Pos','False Neg','True Pos']
    group_counts = ["{0:0.0f}".format(value) for value in cf_matrix.flatten()]
    group_percentages = ["{0:.2%}".format(value) for value in
                     cf_matrix.flatten()/np.sum(cf_matrix)]
    labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names,group_counts,group_percentages)]

    labels = np.asarray(labels).reshape(2,2)

    sns.heatmap(cf_matrix,annot=labels, fmt='', cmap='Blues')
    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')

def main(name):

    train_Y, train_X = read_data1('/home/john/Project/CVE_crawler/Detect_Malware/dataset.csv')

    encoder = LabelEncoder()
    encoder.fit(train_Y)
    train_Y = encoder.transform(train_Y)

    if name != "debug":
        os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

        train_X, test_X, train_Y, test_Y = train_test_split(train_X, train_Y, test_size=0.3)
        
        model = main_model(train_Y, train_X)
        _, train_score = model.evaluate(train_X, train_Y)
        _, test_score = model.evaluate(test_X, test_Y)

        train_score = train_score * 100.0
        test_score = test_score * 100.0

        logger.myLogger("ML model").info(f'Test score ------> {test_score}')
        logger.myLogger("ML model").info(f'Train score -----> {train_score}')

        y_pred = model.predict_classes(test_X)

        plot_confussion(test_Y, y_pred, [0, 1], "Test Confussion matrix")
        plt.savefig('cfmatrix.png', bbox_inches='tight')

    else:
        model = load_model('best_model.h5')
        logger.myLogger("ML model").info("Got model")

        np_arr = np.array([encode_content.encode_pe('/home/john/Project/CVE_crawler/Server/Files/malw.exe_'), ])
        prediction = get_prediction_encoder(model, np_arr, encoder)
        logger.myLogger("ML model").info(f"Predicted: {prediction}")

def get_prediction_encoder(model, test_X, encoder):
    predicted_classes =  model.predict_classes(test_X)
    return encoder.inverse_transform(predicted_classes[0])[0]

def get_predictions(model, test_X):
    return 'pe-malicious' if model.predict_classes(test_X)[0] == [1] else 'pe-legit'

def main_model(train_Y, train_X):
    model = Sequential()
    model.add(Dense(256, input_shape=(train_X.shape[1], ),activation='relu'))
    model.add(Dropout(0.5))
    model.add(Dense(128, activation='relu'))
    model.add(Dense(64, activation='relu'))
    model.add(Dropout(0.3))
    model.add(Dense(1, activation='sigmoid'))
    model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

    es = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=100)
    mc = ModelCheckpoint('best_model.h5', monitor='val_acc', mode='max', save_best_only=True)

    model.fit(train_X, train_Y, epochs=200, verbose=1, validation_split=0.3,
            callbacks=[es, mc])

    saved_model = load_model('best_model.h5')

    return saved_model

if __name__ == "__main__":
    main("train")